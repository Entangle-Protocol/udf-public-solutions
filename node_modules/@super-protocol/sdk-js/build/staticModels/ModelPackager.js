"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelPackager = void 0;
const Compression_1 = require("../proto/Compression");
const compressors_1 = require("../utils/compressors");
class ModelPackager {
    /**
     * Compressing message with best algorithm
     *
     * @param message - message
     * @returns Compressed message in bytes representation
     */
    static pack(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = ModelPackager.compressors.map((Compressor) => __awaiter(this, void 0, void 0, function* () {
                const compressorInstance = new Compressor();
                const data = yield compressorInstance.compress(message);
                return {
                    compressionType: Compressor.type,
                    data,
                    size: data.byteLength,
                };
            }));
            const options = yield Promise.all(promises);
            options.sort((first, second) => first.size - second.size);
            const minimal = options[0];
            const encoded = Compression_1.Compression.encode({
                type: minimal.compressionType,
                data: minimal.data,
            }).finish();
            return Buffer.from(encoded);
        });
    }
    /**
     * Uncompressing message
     *
     * @param message - message with bytes representation
     * @returns original message
     */
    static unpack(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const decoded = Compression_1.Compression.decode(message);
            const Compressor = ModelPackager.compressors.find((CompressorClass) => CompressorClass.type === decoded.type);
            if (!Compressor) {
                throw new Error(`Cannot unpack message. Compressor ${decoded.type} isn't supported`);
            }
            return new Compressor().decompress(Buffer.from(decoded.data));
        });
    }
}
exports.ModelPackager = ModelPackager;
ModelPackager.compressors = [compressors_1.GzipCompressor, compressors_1.UncompressedCompressor];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kZWxQYWNrYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWNNb2RlbHMvTW9kZWxQYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxzREFBbUQ7QUFDbkQsc0RBQThFO0FBRTlFLE1BQWEsYUFBYTtJQUd4Qjs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBTyxJQUFJLENBQWMsT0FBVTs7WUFDOUMsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBTyxVQUFVLEVBQUUsRUFBRTtnQkFDbEUsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO2dCQUM1QyxNQUFNLElBQUksR0FBRyxNQUFNLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFFeEQsT0FBTztvQkFDTCxlQUFlLEVBQUUsVUFBVSxDQUFDLElBQUk7b0JBQ2hDLElBQUk7b0JBQ0osSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVO2lCQUN0QixDQUFDO1lBQ0osQ0FBQyxDQUFBLENBQUMsQ0FBQztZQUVILE1BQU0sT0FBTyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM1QyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTNCLE1BQU0sT0FBTyxHQUFHLHlCQUFXLENBQUMsTUFBTSxDQUFDO2dCQUNqQyxJQUFJLEVBQUUsT0FBTyxDQUFDLGVBQWU7Z0JBQzdCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTthQUNuQixDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFWixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUIsQ0FBQztLQUFBO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQU8sTUFBTSxDQUFjLE9BQWU7O1lBQ3JELE1BQU0sT0FBTyxHQUFHLHlCQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRTVDLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUMvQyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsSUFBSSxDQUMzRCxDQUFDO1lBRUYsSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDZixNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxPQUFPLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3RGO1lBRUQsT0FBTyxJQUFJLFVBQVUsRUFBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25FLENBQUM7S0FBQTs7QUFuREgsc0NBb0RDO0FBbkRnQix5QkFBVyxHQUFHLENBQUMsNEJBQWMsRUFBRSxvQ0FBc0IsQ0FBQyxDQUFDIn0=