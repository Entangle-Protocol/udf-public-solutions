"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../logger"));
const Superpro_1 = __importDefault(require("./Superpro"));
const TxManager_1 = __importDefault(require("../utils/TxManager"));
const helper_1 = require("../utils/helper");
const connectors_1 = require("../connectors");
class Deposits {
    static get address() {
        return Superpro_1.default.address;
    }
    /**
     * Function for fetching deposit info
     * @param depositOwner - Deposit owner
     */
    static getDepositInfo(depositOwner) {
        const contract = connectors_1.BlockchainConnector.getInstance().getContract();
        return (0, helper_1.cleanWeb3Data)(contract.methods.getDepositInfo(depositOwner).call());
    }
    /**
     * Function for fetching amount of locked tokens
     * @param depositOwner - Deposit owner
     */
    static getLockedTokensAmount(depositOwner) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = connectors_1.BlockchainConnector.getInstance().getContract();
            return (0, helper_1.convertBigIntToString)(yield contract.methods.getLockedTokensAmount(depositOwner).call());
        });
    }
    /**
     * Function for replenish deposit
     * @param amount - replenish amount
     * @param transactionOptions - object what contains alternative action account or gas limit (optional)
     * @returns {Promise<void>} - Does not return id of created order!
     */
    static replenish(amount, transactionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = connectors_1.BlockchainConnector.getInstance().getContract();
            (0, helper_1.checkIfActionAccountInitialized)(transactionOptions);
            yield TxManager_1.default.execute(contract.methods.replenish(amount), transactionOptions);
        });
    }
    /**
     * Function for replenish deposit of given account
     * @param beneficiary - account
     * @param amount - replenish amount
     * @param transactionOptions - object what contains alternative action account or gas limit (optional)
     * @returns {Promise<void>} - Does not return id of created order!
     */
    static replenishFor(beneficiary, amount, transactionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = connectors_1.BlockchainConnector.getInstance().getContract();
            (0, helper_1.checkIfActionAccountInitialized)(transactionOptions);
            yield TxManager_1.default.execute(contract.methods.replenishFor(beneficiary, amount), transactionOptions);
        });
    }
    /**
     * Function for withdraw deposit
     * @param amount - withdraw amount
     * @param transactionOptions - object what contains alternative action account or gas limit (optional)
     * @returns {Promise<void>} - Does not return id of created order!
     */
    static withdraw(amount, transactionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = connectors_1.BlockchainConnector.getInstance().getContract();
            (0, helper_1.checkIfActionAccountInitialized)(transactionOptions);
            yield TxManager_1.default.execute(contract.methods.withdraw(amount), transactionOptions);
        });
    }
    /**
     * Function for adding event listeners on DepositReplenished event in contract
     * @param owner - owner address
     * @param callback - function for processing created order
     * @returns unsubscribe - unsubscribe function from event
     */
    static onDepositReplenished(callback, owner) {
        const contract = connectors_1.BlockchainEventsListener.getInstance().getContract();
        const logger = this.logger.child({ method: 'onDepositReplenished' });
        const subscription = contract.events.DepositReplenished();
        subscription.on('data', (event) => {
            const parsedEvent = (0, helper_1.cleanWeb3Data)(event.returnValues);
            if (owner && event.returnValues.owner != owner) {
                return;
            }
            callback(parsedEvent.owner, parsedEvent.amount, parsedEvent.totalLocked, {
                index: Number(event.blockNumber),
                hash: event.blockHash,
            });
        });
        subscription.on('error', (error) => {
            logger.warn(error);
        });
        return () => subscription.unsubscribe();
    }
    /**
     * Function for adding event listeners on DepositWithdrawn event in contract
     * @param owner - owner address
     * @param callback - function for processing created order
     * @returns unsubscribe - unsubscribe function from event
     */
    static onDepositWithdrawn(callback, owner) {
        const contract = connectors_1.BlockchainEventsListener.getInstance().getContract();
        const logger = this.logger.child({ method: 'onDepositWithdrawn' });
        const subscription = contract.events.DepositWithdrawn();
        subscription.on('data', (event) => {
            const parsedEvent = (0, helper_1.cleanWeb3Data)(event.returnValues);
            if (owner && parsedEvent.owner != owner) {
                return;
            }
            callback(parsedEvent.owner, parsedEvent.amount, parsedEvent.totalLocked, {
                index: Number(event.blockNumber),
                hash: event.blockHash,
            });
        });
        subscription.on('error', (error) => {
            logger.warn(error);
        });
        return () => subscription.unsubscribe();
    }
    /**
     * Function for adding event listeners on DepositPartLocked event in contract
     * @param owner - owner address
     * @param callback - function for processing created order
     * @returns unsubscribe - unsubscribe function from event
     */
    static onDepositPartLocked(callback, owner) {
        const contract = connectors_1.BlockchainEventsListener.getInstance().getContract();
        const logger = this.logger.child({ method: 'onDepositPartLocked' });
        const subscription = contract.events.DepositPartLocked();
        subscription.on('data', (event) => {
            const parsedEvent = (0, helper_1.cleanWeb3Data)(event.returnValues);
            if (owner && parsedEvent.owner != owner) {
                return;
            }
            callback(parsedEvent.owner, parsedEvent.amount, parsedEvent.totalLocked, {
                index: Number(event.blockNumber),
                hash: event.blockHash,
            });
        });
        subscription.on('error', (error) => {
            logger.warn(error);
        });
        return () => subscription.unsubscribe();
    }
    /**
     * Function for adding event listeners on DepositPartUnlocked event in contract
     * @param owner - owner address
     * @param callback - function for processing created order
     * @returns unsubscribe - unsubscribe function from event
     */
    static onDepositPartUnlocked(callback, owner) {
        const contract = connectors_1.BlockchainEventsListener.getInstance().getContract();
        const logger = this.logger.child({ method: 'onDepositPartUnlocked' });
        const subscription = contract.events.DepositPartUnlocked();
        subscription.on('data', (event) => {
            const parsedEvent = (0, helper_1.cleanWeb3Data)(event.returnValues);
            if (owner && parsedEvent.owner != owner) {
                return;
            }
            callback(parsedEvent.owner, parsedEvent.amount, parsedEvent.totalLocked, {
                index: Number(event.blockNumber),
                hash: event.blockHash,
            });
        });
        subscription.on('error', (error) => {
            logger.warn(error);
        });
        return () => subscription.unsubscribe();
    }
}
Deposits.logger = logger_1.default.child({ className: 'Deposits' });
__decorate([
    (0, helper_1.incrementMethodCall)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Deposits, "replenish", null);
__decorate([
    (0, helper_1.incrementMethodCall)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", Promise)
], Deposits, "replenishFor", null);
__decorate([
    (0, helper_1.incrementMethodCall)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Deposits, "withdraw", null);
exports.default = Deposits;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVwb3NpdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RhdGljTW9kZWxzL0RlcG9zaXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQW1DO0FBQ25DLDBEQUFrQztBQUNsQyxtRUFBMkM7QUFDM0MsNENBS3lCO0FBQ3pCLDhDQUE4RTtBQUk5RSxNQUFNLFFBQVE7SUFHTCxNQUFNLEtBQUssT0FBTztRQUN2QixPQUFPLGtCQUFRLENBQUMsT0FBTyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLFlBQW9CO1FBQy9DLE1BQU0sUUFBUSxHQUFHLGdDQUFtQixDQUFDLFdBQVcsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWpFLE9BQU8sSUFBQSxzQkFBYSxFQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBTyxxQkFBcUIsQ0FBQyxZQUFvQjs7WUFDNUQsTUFBTSxRQUFRLEdBQUcsZ0NBQW1CLENBQUMsV0FBVyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUM7WUFFakUsT0FBTyxJQUFBLDhCQUFxQixFQUFDLE1BQU0sUUFBUSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ2xHLENBQUM7S0FBQTtJQUVEOzs7OztPQUtHO0lBRWlCLEFBQWIsTUFBTSxDQUFPLFNBQVMsQ0FDM0IsTUFBbUIsRUFDbkIsa0JBQXVDOztZQUV2QyxNQUFNLFFBQVEsR0FBRyxnQ0FBbUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqRSxJQUFBLHdDQUErQixFQUFDLGtCQUFrQixDQUFDLENBQUM7WUFFcEQsTUFB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