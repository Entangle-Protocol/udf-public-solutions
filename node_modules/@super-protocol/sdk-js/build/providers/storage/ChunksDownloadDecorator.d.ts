/// <reference types="node" />
/// <reference types="node" />
import { Readable } from 'stream';
import StorageObject from '../../types/storage/StorageObject';
import IStorageProvider, { DownloadConfig } from './IStorageProvider';
export type DownloadChunkMethodType = (provider: IStorageProvider, objectPath: string, chunk: ChunkType) => Promise<Buffer>;
export type RetryDownloadChunkOptions = {
    retryMaxCount?: number;
    onRetry?: (error: unknown, chunk: ChunkType, attemptLeft: number) => void;
    retryWaitTimeFactory?: () => () => number;
};
export type ChunkType = {
    offset: bigint;
    length: number;
    dataSize: bigint;
    chunk: number;
    chunkCount: number;
};
export declare const downloadChunkMethod: (provider: IStorageProvider, objectPath: string, chunk: ChunkType) => Promise<Buffer>;
export declare const createDownloadChunkMethodWithRetry: (downloadChunkMethod: DownloadChunkMethodType, { retryMaxCount, retryWaitTimeFactory, onRetry, }?: RetryDownloadChunkOptions) => DownloadChunkMethodType;
export declare class DownloadDecorator implements IStorageProvider {
    private provider;
    private chunkDownloaderMethod;
    private options;
    constructor(provider: IStorageProvider, chunkDownloaderMethod: DownloadChunkMethodType, options: {
        chunkSize: number;
        concurrency: number;
        offset?: number;
    });
    uploadFile(inputStream: Readable, remotePath: string, contentLength: number, progressListener?: (total: number, current: number) => void): Promise<void>;
    downloadFile(remotePath: string, config?: DownloadConfig, progressListener?: (total: number, current: number) => void): Promise<Readable>;
    deleteObject(remotePath: string): Promise<void>;
    listObjects(remotePath: string): Promise<StorageObject[]>;
    getObjectSize(remotePath: string): Promise<number>;
    getLastModified(remotePath: string): Promise<Date | null>;
}
