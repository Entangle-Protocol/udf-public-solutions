/// <reference types="node" />
import StorageAccess from '../../types/storage/StorageAccess';
import { Performance } from './types';
export interface LRUCacheConfig {
    max: number;
}
export interface StorageAdapterConfig {
    lruCache: LRUCacheConfig;
    writeInterval: number;
    readInterval: number;
    objectDeletedFlag: string;
    readMetadataConcurrency?: number;
    performance?: Performance;
    showLogs?: boolean;
}
export declare enum CacheEvents {
    INSTANCES_CHANGED = "INSTANCES_CHANGED",
    KEY_DELETED = "KEY_DELETED"
}
export default class StorageAdapter<V extends object> {
    private readonly logger?;
    private readonly storageKeyValueAdapter;
    private readonly cache;
    private readonly encryptionKeys;
    private readonly contentWriter;
    private readonly metadataReader;
    private readonly instanceId;
    private timeout;
    private readonly readInterval;
    private readonly queues;
    private readonly queueReadMetadata;
    private readonly isUpdating;
    private readonly pubSub;
    private readonly eventName;
    private readonly performance?;
    constructor(storageAccess: StorageAccess, config: StorageAdapterConfig);
    private generateHash;
    subscribe(cb: (props: {
        type: CacheEvents;
        message: unknown;
    }) => void): Promise<() => Promise<void>>;
    private publish;
    has(key: string): Promise<boolean>;
    private getEnryptionKey;
    set(key: string, value: V, encryptionKeyBuffer: Buffer): Promise<void>;
    private setByInstance;
    delete(key: string): Promise<void>;
    get(key: string, encryptionKeyBuffer: Buffer): Promise<(V | null)[] | null>;
    private getQueue;
    private clearQueue;
    private cacheHasNullInstances;
    private fetchNullValues;
    clear(): void;
    run(): void;
    private checkUpdates;
    private startUpdatesChecking;
    private stopUpdatesChecking;
    stop(): void;
    shutdown(): Promise<void>;
}
