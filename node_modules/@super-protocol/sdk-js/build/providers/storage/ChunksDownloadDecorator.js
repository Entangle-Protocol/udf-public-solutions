"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadDecorator = exports.createDownloadChunkMethodWithRetry = exports.downloadChunkMethod = void 0;
const stream_1 = require("stream");
function* generateChunks(dataSize, chunkSize, startOffset = BigInt(0)) {
    let chunk = 0;
    let offset = startOffset;
    while (dataSize > offset) {
        yield {
            offset,
            length: chunkSize > dataSize - offset ? Number(dataSize - offset) : chunkSize,
            dataSize,
            chunk: chunk++,
            chunksCount: Math.ceil(Number(dataSize / BigInt(chunkSize))),
        };
        offset += BigInt(chunkSize);
    }
}
class ChunkedReadableTransform extends stream_1.Transform {
    constructor(downloadChunk, params) {
        super({
            objectMode: true,
            highWaterMark: params.concurrency,
        });
        this.downloadChunk = downloadChunk;
    }
    _transform(chunk, encoding, callback) {
        const resultPromise = this.downloadChunk(chunk);
        callback(null, {
            resultPromise,
            chunk,
        });
    }
}
class ChainedChunksReadableTransform extends stream_1.Transform {
    constructor(progressListener) {
        super({
            objectMode: true,
            highWaterMark: 1,
        });
        this.progressListener = progressListener;
    }
    _transform(obj, encoding, callback) {
        obj.resultPromise.then((data) => {
            callback(null, data);
            if (this.progressListener) {
                this.progressListener(Number(obj.chunk.dataSize), Number(obj.chunk.offset) + obj.chunk.length);
            }
        }, (err) => {
            callback(err);
        });
    }
}
const downloadChunkMethod = (provider, objectPath, chunk) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, e_1, _b, _c;
    let position = 0;
    const buffer = Buffer.alloc(chunk.length);
    const dataStream = yield provider.downloadFile(objectPath, {
        offset: Number(chunk.offset),
        length: chunk.length,
    });
    try {
        for (var _d = true, dataStream_1 = __asyncValues(dataStream), dataStream_1_1; dataStream_1_1 = yield dataStream_1.next(), _a = dataStream_1_1.done, !_a;) {
            _c = dataStream_1_1.value;
            _d = false;
            try {
                const data = _c;
                data.copy(buffer, position);
                position += data.length;
                if (position > chunk.length) {
                    throw new Error('Chunk buffer is overflow, read data is more than requested for chunk');
                }
            }
            finally {
                _d = true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (!_d && !_a && (_b = dataStream_1.return)) yield _b.call(dataStream_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return buffer;
});
exports.downloadChunkMethod = downloadChunkMethod;
const createDownloadChunkMethodWithRetry = (downloadChunkMethod, { retryMaxCount = 3, retryWaitTimeFactory = () => () => 1000, onRetry, } = {}) => {
    return (provider, objectPath, chunk) => __awaiter(void 0, void 0, void 0, function* () {
        const retryWaitTime = retryWaitTimeFactory();
        //let lastError: unknown = null;
        let retryCount = retryMaxCount;
        while (retryCount > 0) {
            try {
                return yield downloadChunkMethod(provider, objectPath, chunk);
            }
            catch (error) {
                //lastError = error;
            }
            retryCount--;
            if (onRetry) {
                onRetry(null, chunk, retryCount);
            }
            if (retryCount !== 0) {
                yield new Promise((resolve, reject) => setTimeout(resolve, retryWaitTime()));
            }
        }
        throw new Error(`Max retry attempts was reached for object path ${objectPath}, offset ${chunk.offset}, length ${chunk.length
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }`);
    });
};
exports.createDownloadChunkMethodWithRetry = createDownloadChunkMethodWithRetry;
class DownloadDecorator {
    constructor(provider, chunkDownloaderMethod, options) {
        this.provider = provider;
        this.chunkDownloaderMethod = chunkDownloaderMethod;
        this.options = options;
    }
    uploadFile(inputStream, remotePath, contentLength, progressListener) {
        return this.provider.uploadFile(inputStream, remotePath, contentLength, progressListener);
    }
    downloadFile(remotePath, config, progressListener) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (config === null || config === void 0 ? void 0 : config.length) {
                return this.provider.downloadFile(remotePath, config, progressListener);
            }
            const offset = BigInt((_a = this.options.offset) !== null && _a !== void 0 ? _a : 0);
            const objectSize = yield this.provider.getObjectSize(remotePath);
            const chunksStream = stream_1.Readable.from(generateChunks(BigInt(objectSize), this.options.chunkSize, offset));
            const downloadStream = new ChunkedReadableTransform((chunk) => __awaiter(this, void 0, void 0, function* () {
                return this.chunkDownloaderMethod(this.provider, remotePath, chunk);
            }), {
                concurrency: this.options.concurrency,
            });
            const chainedStream = new ChainedChunksReadableTransform(progressListener);
            return chunksStream
                .pipe(downloadStream)
                .on('error', (error) => {
                chainedStream.emit('error', error);
            })
                .pipe(chainedStream);
        });
    }
    deleteObject(remotePath) {
        return this.provider.deleteObject(remotePath);
    }
    listObjects(remotePath) {
        return this.provider.listObjects(remotePath);
    }
    getObjectSize(remotePath) {
        return this.provider.getObjectSize(remotePath);
    }
    getLastModified(remotePath) {
        return this.provider.getLastModified(remotePath);
    }
}
exports.DownloadDecorator = DownloadDecorator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2h1bmtzRG93bmxvYWREZWNvcmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJvdmlkZXJzL3N0b3JhZ2UvQ2h1bmtzRG93bmxvYWREZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1DQUFnRTtBQXdCaEUsUUFBUSxDQUFDLENBQUMsY0FBYyxDQUFDLFFBQWdCLEVBQUUsU0FBaUIsRUFBRSxXQUFXLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNuRixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxJQUFJLE1BQU0sR0FBRyxXQUFXLENBQUM7SUFFekIsT0FBTyxRQUFRLEdBQUcsTUFBTSxFQUFFO1FBQ3hCLE1BQU07WUFDSixNQUFNO1lBQ04sTUFBTSxFQUFFLFNBQVMsR0FBRyxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQzdFLFFBQVE7WUFDUixLQUFLLEVBQUUsS0FBSyxFQUFFO1lBQ2QsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUM3RCxDQUFDO1FBRUYsTUFBTSxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUM3QjtBQUNILENBQUM7QUFFRCxNQUFNLHdCQUF5QixTQUFRLGtCQUFTO0lBQzlDLFlBQ1UsYUFBb0QsRUFDNUQsTUFBK0I7UUFFL0IsS0FBSyxDQUFDO1lBQ0osVUFBVSxFQUFFLElBQUk7WUFDaEIsYUFBYSxFQUFFLE1BQU0sQ0FBQyxXQUFXO1NBQ2xDLENBQUMsQ0FBQztRQU5LLGtCQUFhLEdBQWIsYUFBYSxDQUF1QztJQU85RCxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQWdCLEVBQUUsUUFBd0IsRUFBRSxRQUEy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