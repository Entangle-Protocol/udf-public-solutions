"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dto_js_1 = require("@super-protocol/dto-js");
const AES_1 = __importDefault(require("./nodejs/AES"));
const ARIA_1 = __importDefault(require("./nodejs/ARIA"));
const ECIES_1 = __importDefault(require("./nodejs/ECIES"));
const RSA_Hybrid_1 = __importDefault(require("./nodejs/RSA-Hybrid"));
const NativeCrypto_1 = __importDefault(require("./nodejs/NativeCrypto"));
class Crypto {
    /**
     * Used to encrypt data before sending it to blockchain
     * @param algorithm - encryption algorithm
     * @param content - string data to encrypt
     * @param key - key in string format (default encoding base64)
     * @param encoding - encoding of key and output data
     * @returns {Promise<Encryption>} - object what contains encrypted data, key and spec to decryption
     */
    static encrypt(content, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (encryption.algo) {
                case dto_js_1.CryptoAlgorithm.AES:
                    return yield AES_1.default.encrypt(content, encryption);
                case dto_js_1.CryptoAlgorithm.ARIA:
                    return yield ARIA_1.default.encrypt(content, encryption);
                case dto_js_1.CryptoAlgorithm.ECIES:
                    return yield ECIES_1.default.encrypt(content, encryption);
                case dto_js_1.CryptoAlgorithm.RSAHybrid:
                    return yield RSA_Hybrid_1.default.encrypt(content, encryption);
                default:
                    throw Error(`${encryption.algo} algorithm not supported`);
            }
        });
    }
    /**
     * Encrypts data stream
     * @param inputStream - path to file that will be encrypted
     * @param outputStream - place where it will be saved
     * @param algorithm - file encryption algorithm
     * @param key – key that will be used to encrypt data
     * @returns {Promise<Encryption>} - encryption info
     */
    static encryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (encryption.algo) {
                case dto_js_1.CryptoAlgorithm.AES:
                    return yield AES_1.default.encryptStream(inputStream, outputStream, encryption);
                case dto_js_1.CryptoAlgorithm.ARIA:
                    return yield ARIA_1.default.encryptStream(inputStream, outputStream, encryption);
                case dto_js_1.CryptoAlgorithm.RSAHybrid:
                    return yield RSA_Hybrid_1.default.encryptStream(inputStream, outputStream, encryption);
                default:
                    throw Error(`${encryption.algo} algorithm not supported`);
            }
        });
    }
    /**
     * Used to decrypt data from blockchain
     * @param encryption - object what contains encrypted data, key and spec to decryption
     * @returns {Promise<string>} - decrypted string
     */
    static decrypt(encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (encryption.algo) {
                case dto_js_1.CryptoAlgorithm.AES:
                    return AES_1.default.decrypt(encryption);
                case dto_js_1.CryptoAlgorithm.ARIA:
                    return ARIA_1.default.decrypt(encryption);
                case dto_js_1.CryptoAlgorithm.ECIES:
                    return yield ECIES_1.default.decrypt(encryption);
                case dto_js_1.CryptoAlgorithm.RSAHybrid:
                    return RSA_Hybrid_1.default.decrypt(encryption);
                default:
                    throw Error(`${encryption.algo} algorithm not supported`);
            }
        });
    }
    /**
     * Decrypts data stream
     * @param inputStream - stream with data to decrypt
     * @param outputStream - stream where the decrypted data will be written
     * @param encryption – encryption info
     */
    static decryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (encryption.algo) {
                case dto_js_1.CryptoAlgorithm.AES:
                    return yield AES_1.default.decryptStream(inputStream, outputStream, encryption);
                case dto_js_1.CryptoAlgorithm.ARIA:
                    return yield ARIA_1.default.decryptStream(inputStream, outputStream, encryption);
                case dto_js_1.CryptoAlgorithm.RSAHybrid:
                    return yield RSA_Hybrid_1.default.decryptStream(inputStream, outputStream, encryption);
                default:
                    throw Error(`${encryption.algo} algorithm not supported`);
            }
        });
    }
    static createHash(param1, hashInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const { algo, encoding } = hashInfo;
            return Buffer.isBuffer(param1)
                ? NativeCrypto_1.default.createHashFromBuffer(param1, algo, encoding)
                : yield NativeCrypto_1.default.createHashFromStream(param1, algo, encoding);
        });
    }
}
exports.default = Crypto;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NyeXB0by9DcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFRZ0M7QUFFaEMsdURBQStCO0FBQy9CLHlEQUFpQztBQUNqQywyREFBbUM7QUFDbkMscUVBQTRDO0FBQzVDLHlFQUFpRDtBQUdqRCxNQUFNLE1BQU07SUFDVjs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFPLE9BQU8sQ0FBQyxPQUFlLEVBQUUsVUFBc0I7O1lBQzFELFFBQVEsVUFBVSxDQUFDLElBQUksRUFBRTtnQkFDdkIsS0FBSyx3QkFBZSxDQUFDLEdBQUc7b0JBQ3RCLE9BQU8sTUFBTSxhQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFaEQsS0FBSyx3QkFBZSxDQUFDLElBQUk7b0JBQ3ZCLE9BQU8sTUFBTSxjQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFakQsS0FBSyx3QkFBZSxDQUFDLEtBQUs7b0JBQ3hCLE9BQU8sTUFBTSxlQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFbEQsS0FBSyx3QkFBZSxDQUFDLFNBQVM7b0JBQzVCLE9BQU8sTUFBTSxvQkFBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7Z0JBRXREO29CQUNFLE1BQU0sS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksMEJBQTBCLENBQUMsQ0FBQzthQUM3RDtRQUNILENBQUM7S0FBQTtJQUVEOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQU8sYUFBYSxDQUMvQixXQUEwQixFQUMxQixZQUE0QixFQUM1QixVQUFzQjs7WUFFdEIsUUFBUSxVQUFVLENBQUMsSUFBSSxFQUFFO2dCQUN2QixLQUFLLHdCQUFlLENBQUMsR0FBRztvQkFDdEIsT0FBTyxN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