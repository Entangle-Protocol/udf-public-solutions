"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dto_js_1 = require("@super-protocol/dto-js");
const NativeCrypto_1 = __importDefault(require("./NativeCrypto"));
class ARIA {
    static encrypt(content, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Encryption key is not provided');
            encryption.cipher = encryption.cipher || dto_js_1.Cipher.ARIA_256_GCM;
            const keyBuffer = Buffer.from(encryption.key, encryption.encoding);
            const encrypted = NativeCrypto_1.default.encrypt(keyBuffer, content, encryption.cipher);
            return {
                algo: dto_js_1.CryptoAlgorithm.ARIA,
                encoding: encryption.encoding,
                cipher: encryption.cipher,
                ciphertext: encrypted.ciphertext,
                iv: encrypted.iv,
                mac: encrypted.mac,
            };
        });
    }
    /**
     * Encrypts data stream
     * @param inputStream - path to file that will be encrypted
     * @param outputStream - place where it will be saved
     * @param algorithm - file encryption algorithm
     * @param key – key that will be used to encrypt data
     * @returns {Promise<Encryption>} - encryption info
     */
    static encryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Encryption key is not provided');
            encryption.cipher = encryption.cipher || dto_js_1.Cipher.ARIA_256_GCM;
            const keyBuffer = Buffer.from(encryption.key, encryption.encoding);
            const encrypted = yield NativeCrypto_1.default.encryptStream(keyBuffer, inputStream, outputStream, encryption.cipher);
            return {
                algo: dto_js_1.CryptoAlgorithm.ARIA,
                encoding: encryption.encoding,
                cipher: encryption.cipher,
                iv: encrypted.iv,
                mac: encrypted.mac,
            };
        });
    }
    static decrypt(encryption) {
        if (!encryption.key)
            throw Error('Decryption key is not provided');
        const key = Buffer.from(encryption.key, encryption.encoding);
        const params = {
            iv: Buffer.from(encryption.iv, encryption.encoding),
        };
        if (encryption.mac) {
            params.mac = Buffer.from(encryption.mac, encryption.encoding);
        }
        return NativeCrypto_1.default.decrypt(key, encryption.ciphertext, encryption.cipher, params, encryption.encoding);
    }
    /**
     * Decrypts data stream
     * @param inputStream - stream with data to decrypt
     * @param outputStream - stream where the decrypted data will be written
     * @param encryption – encryption info
     */
    static decryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Decryption key is not provided');
            const key = Buffer.from(encryption.key, encryption.encoding);
            const params = {
                iv: Buffer.from(encryption.iv, encryption.encoding),
            };
            if (encryption.mac) {
                params.mac = Buffer.from(encryption.mac, encryption.encoding);
            }
            yield NativeCrypto_1.default.decryptStream(key, inputStream, outputStream, encryption.cipher, params);
        });
    }
}
exports.default = ARIA;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVJJQS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jcnlwdG8vbm9kZWpzL0FSSUEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFNZ0M7QUFHaEMsa0VBQTBDO0FBRTFDLE1BQU0sSUFBSTtJQUNELE1BQU0sQ0FBTyxPQUFPLENBQUMsT0FBZSxFQUFFLFVBQXNCOztZQUNqRSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUc7Z0JBQUUsTUFBTSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNuRSxVQUFVLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxNQUFNLElBQUksZUFBTSxDQUFDLFlBQVksQ0FBQztZQUU3RCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRW5FLE1BQU0sU0FBUyxHQUFHLHNCQUFZLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTlFLE9BQU87Z0JBQ0wsSUFBSSxFQUFFLHdCQUFlLENBQUMsSUFBSTtnQkFDMUIsUUFBUSxFQUFFLFVBQVUsQ0FBQyxRQUFRO2dCQUM3QixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQXlDO2dCQUM1RCxVQUFVLEVBQUUsU0FBUyxDQUFDLFVBQVU7Z0JBQ2hDLEVBQUUsRUFBRSxTQUFTLENBQUMsRUFBRztnQkFDakIsR0FBRyxFQUFFLFNBQVMsQ0FBQyxHQUFJO2FBQ3BCLENBQUM7UUFDSixDQUFDO0tBQUE7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFPLGFBQWEsQ0FDL0IsV0FBdUIsRUFDdkIsWUFBeUIsRUFDekIsVUFBc0I7O1lBRXRCLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRztnQkFBRSxNQUFNLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1lBQ25F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