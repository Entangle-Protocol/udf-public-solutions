"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dto_js_1 = require("@super-protocol/dto-js");
const NativeCrypto_1 = __importDefault(require("./NativeCrypto"));
class AES {
    static encrypt(content, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Encryption key is not provided');
            encryption.cipher = encryption.cipher || dto_js_1.Cipher.AES_256_GCM;
            const keyBuffer = Buffer.from(encryption.key, encryption.encoding);
            const encrypted = NativeCrypto_1.default.encrypt(keyBuffer, content, encryption.cipher);
            return {
                algo: dto_js_1.CryptoAlgorithm.AES,
                encoding: encryption.encoding,
                cipher: encryption.cipher,
                ciphertext: encrypted.ciphertext,
                iv: encrypted.iv,
                mac: encrypted.mac,
            };
        });
    }
    /**
     * Encrypts data stream
     * @param inputStream - path to file that will be encrypted
     * @param outputStream - place where it will be saved
     * @param algorithm - file encryption algorithm
     * @param key – key that will be used to encrypt data
     * @returns {Promise<Encryption>} - encryption info
     */
    static encryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Encryption key is not provided');
            encryption.cipher = encryption.cipher || dto_js_1.Cipher.AES_256_GCM;
            const keyBuffer = Buffer.from(encryption.key, encryption.encoding);
            const encrypted = yield NativeCrypto_1.default.encryptStream(keyBuffer, inputStream, outputStream, encryption.cipher);
            return {
                algo: encryption.algo,
                encoding: encryption.encoding,
                cipher: encryption.cipher,
                ciphertext: encrypted.ciphertext,
                iv: encrypted.iv,
                mac: encrypted.mac,
            };
        });
    }
    static decrypt(encryption) {
        if (!encryption.key)
            throw Error('Decryption key is not provided');
        const key = Buffer.from(encryption.key, encryption.encoding);
        const params = {
            iv: Buffer.from(encryption.iv, encryption.encoding),
        };
        if (encryption.mac) {
            params.mac = Buffer.from(encryption.mac, encryption.encoding);
        }
        return NativeCrypto_1.default.decrypt(key, encryption.ciphertext, encryption.cipher, params, encryption.encoding);
    }
    /**
     * Decrypts data stream
     * @param inputStream - stream with data to decrypt
     * @param outputStream - stream where the decrypted data will be written
     * @param encryption – encryption info
     */
    static decryptStream(inputStream, outputStream, encryption) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!encryption.key)
                throw Error('Decryption key is not provided');
            const key = Buffer.from(encryption.key, encryption.encoding);
            const params = {
                iv: Buffer.from(encryption.iv, encryption.encoding),
            };
            if (encryption.mac) {
                params.mac = Buffer.from(encryption.mac, encryption.encoding);
            }
            yield NativeCrypto_1.default.decryptStream(key, inputStream, outputStream, encryption.cipher, params);
        });
    }
}
exports.default = AES;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQUVTLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NyeXB0by9ub2RlanMvQUVTLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbURBTWdDO0FBR2hDLGtFQUEwQztBQUUxQyxNQUFNLEdBQUc7SUFDQSxNQUFNLENBQU8sT0FBTyxDQUFDLE9BQWUsRUFBRSxVQUFzQjs7WUFDakUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHO2dCQUFFLE1BQU0sS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDbkUsVUFBVSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxJQUFJLGVBQU0sQ0FBQyxXQUFXLENBQUM7WUFFNUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuRSxNQUFNLFNBQVMsR0FBRyxzQkFBWSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUU5RSxPQUFPO2dCQUNMLElBQUksRUFBRSx3QkFBZSxDQUFDLEdBQUc7Z0JBQ3pCLFFBQVEsRUFBRSxVQUFVLENBQUMsUUFBUTtnQkFDN0IsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUF3QztnQkFDM0QsVUFBVSxFQUFFLFNBQVMsQ0FBQyxVQUFVO2dCQUNoQyxFQUFFLEVBQUUsU0FBUyxDQUFDLEVBQUc7Z0JBQ2pCLEdBQUcsRUFBRSxTQUFTLENBQUMsR0FBSTthQUNwQixDQUFDO1FBQ0osQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBTyxhQUFhLENBQy9CLFdBQXVCLEVBQ3ZCLFlBQXlCLEVBQ3pCLFVBQXNCOztZQUV0QixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUc7Z0JBQUUsTUFBTSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNuRSxV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